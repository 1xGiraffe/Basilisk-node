<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Statics initialized with non const functions."><meta name="keywords" content="rust, rustlang, rust-lang, dynamic"><title>dynamic in static_init - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-1f7d512b176f0f72.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-124a1ca42af929b6.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-e963ab4a0d0c903e.css" id="mainThemeStyle"><link rel="stylesheet" id="themeStyle" href="../static.files/light-046227e470cd3629.css"><link rel="stylesheet" disabled href="../static.files/dark-800f2ee593c8e6f7.css"><link rel="stylesheet" disabled href="../static.files/ayu-9edae3c387f5a5b3.css"><script id="default-settings" ></script><script src="../static.files/storage-d43fa987303ecbbb.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-287cecec4dbb45b0.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc attr"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../static_init/index.html"><div class="logo-container"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></div></a><h2></h2></nav><nav class="sidebar"><a class="sidebar-logo" href="../static_init/index.html"><div class="logo-container"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></div></a><div class="sidebar-elems"><h2><a href="index.html">In static_init</a></h2></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-5ec35bf9ca753509.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1 class="fqn">Attribute Macro <a href="index.html">static_init</a>::<wbr><a class="attr" href="#">dynamic</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../src/static_init_macro/lib.rs.html#450">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><div class="item-decl"><pre class="rust attr"><code>#[dynamic]</code></pre></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Statics initialized with non const functions.</p>
<p>Statics on which this attribute is applied will be be initialized at run time (optionaly see
bellow), before main start. This allow statics initialization with non const expressions.</p>
<p>There are two variants of dynamic statics:</p>
<h2 id="dynamic-lazy-statics"><a href="#dynamic-lazy-statics">Dynamic lazy statics</a></h2>
<p>These dynamics are supported on all plateforms and requires std support. Lazy dynamics are
enabled by the default feature “lazy”.</p>
<p>Lazy statics are declared with the <code>[dynamic(lazy)]</code> or simply <code>[dynamic]</code> attribute. On unixes and windows plateforms these
statics are optimized versions of [std::lazy::SyncLazy]. After program initialization phase,
those statics are guaranteed to be initialized and access to them will be as fast as any access
to a regular static. On other plateforms, those statics are equivalent to [std::lazy::SyncLazy].</p>

<div class="example-wrap ignore"><div class='tooltip'>ⓘ</div><pre class="rust rust-example-rendered"><code><span class="kw">struct </span>A(i32);

<span class="kw">impl </span>A {
  <span class="comment">//new is not const
  </span><span class="kw">fn </span>new(v:i32) -&gt; A {
    A(v)
  }
}

<span class="attr">#[dynamic] </span><span class="comment">//equivalently #[dynamic(lazy)]
</span><span class="kw">static </span>V :A = A::new(<span class="number">42</span>);</code></pre></div>
<p>Optionnaly, if the default feature “atexit” is enabled, lazy dynamic statics declared with
<code>[dynamic(lazy,drop)]</code> will be dropped at program exit. Dropped lazy dynamic statics ared
dropped in the reverse order of their initialization. This feature is implemented thanks to
<code>libc::atexit</code>. See also <code>drop_reverse</code> attribute argument.</p>

<div class="example-wrap ignore"><div class='tooltip'>ⓘ</div><pre class="rust rust-example-rendered"><code><span class="kw">struct </span>A(i32);

<span class="kw">impl </span>A {
  <span class="comment">//new is not const
  </span><span class="kw">fn </span>new(v:i32) -&gt; A {
    A(v)
  }
}

<span class="kw">impl </span>Drop <span class="kw">for </span>A {
    <span class="kw">fn </span>drop(<span class="kw-2">&amp;mut </span>A){
        <span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>,A.<span class="number">0</span>)
    }
}

<span class="comment">// V2 is initialized before V1,
// so V1 will be dropped before V2
// The program will print:
// 33
// 42
</span><span class="attr">#[dynamic(lazy,drop)]
</span><span class="kw">static </span>V1 :A = A::new(<span class="kw">unsafe</span>{V2.<span class="number">0</span>} - <span class="number">9</span>);

<span class="attr">#[dynamic(drop)] </span><span class="comment">//implies lazy
</span><span class="kw">static </span>V2 :A = A::new(<span class="number">42</span>);</code></pre></div>
<p>Even if V1 is const, access to it must be unsafe because its state may be dropped.
Internaly the procedural macro change V1 to a mutable statics and wrap it in a type
that does not implement <code>DerefMut</code>.</p>
<h3 id="thread-locals"><a href="#thread-locals">Thread locals</a></h3>
<p><em>lazy statics</em> can be declared for thread local. This feature does not require std support. 
They also can be dropped with if the <code>thread_local_drop</code> feature is enabled. 
This last feature does require std support.</p>

<div class="example-wrap ignore"><div class='tooltip'>ⓘ</div><pre class="rust rust-example-rendered"><code><span class="attr">#[thread_local]
#[dynamic(lazy,drop)]
</span><span class="kw">static </span>V1 :A = A::new(<span class="kw">unsafe</span>{V2.<span class="number">0</span>} - <span class="number">9</span>);

<span class="attr">#[thread_local]
#[dynamic(drop)] </span><span class="comment">//implies lazy
</span><span class="kw">static </span>V2 :A = A::new(<span class="number">42</span>);</code></pre></div>
<h2 id="dynamic-statics"><a href="#dynamic-statics">Dynamic statics</a></h2>
<p>Those statics will be initialized at program startup, without ordering, accept between those
that have different priorities on plateform that support priorities. Those statics are
supported on unixes and windows with priorities and mac without priorities.</p>
<h3 id="safety"><a href="#safety">Safety</a></h3>
<p>Initialization expressions must be unsafe blocks. During initialization, any access to other
“dynamic” statics initialized with a lower priority will cause undefined behavior. Similarly,
during drop any access to a “dynamic” static dropped with a lower priority will cause undefined
behavior.</p>

<div class="example-wrap ignore"><div class='tooltip'>ⓘ</div><pre class="rust rust-example-rendered"><code><span class="kw">struct </span>A(i32);

<span class="kw">impl </span>A {
  <span class="comment">//new is not const
  </span><span class="kw">fn </span>new(v:i32) -&gt; A {
    A(v)
  }
}

<span class="attr">#[dynamic(<span class="number">0</span>)]
</span><span class="kw">static </span>V :A = A::new(<span class="number">42</span>);</code></pre></div>
<h3 id="execution-order"><a href="#execution-order">Execution Order</a></h3>
<p>The execution order of “dynamic” static initializations is unspecified. Nevertheless on ELF plateform (linux,any unixes but mac) and
windows plateform a priority can be specified using the syntax <code>dynamic(&lt;num&gt;)</code> where
<code>&lt;num&gt;</code> is a number included in the range [0 ; 2<sup>16</sup>-1].</p>
<p>Statics with priority number 65535 are initialized first (in unspecified order), then statics
with priority number 65534 are initialized …  then statics
with priority number 0.</p>

<div class="example-wrap ignore"><div class='tooltip'>ⓘ</div><pre class="rust rust-example-rendered"><code><span class="kw">struct </span>A(i32);

<span class="kw">impl </span>A {
  <span class="comment">//new is not const
  </span><span class="kw">fn </span>new(v:i32) -&gt; A {
    A(v)
  }
}

<span class="comment">//V1 must be initialized first
//because V2 uses the value of V1.
</span><span class="attr">#[dynamic(<span class="number">10</span>)]
</span><span class="kw">static </span><span class="kw-2">mut </span>V1 :A = A::new(<span class="number">33</span>);

<span class="attr">#[dynamic(<span class="number">20</span>)]
</span><span class="kw">static </span>V2 :A = <span class="kw">unsafe</span>{A::new(V1.<span class="number">0 </span>+ <span class="number">9</span>)};</code></pre></div>
<h2 id="full-syntax-and-dropped-statics"><a href="#full-syntax-and-dropped-statics">Full syntax and dropped statics</a></h2>
<p>Finaly the full syntax is for the attribute is:</p>
<div class="example-wrap"><pre class="language-text"><code>&quot;dynamic&quot; [ &quot;(&quot; &lt;dyn_opts&gt; &quot;)&quot; ]

dyn_opts:
  &lt;dyn_opt&gt;
  &lt;dyn_opt&gt;, &lt;dyn_opts&gt;

dyn_opt:
  &quot;init&quot; [ &quot;=&quot; &lt;priority&gt; ]
  &quot;drop&quot; [ &quot;=&quot; &lt;priority&gt; ]
  &quot;lazy&quot;
  &quot;drop_only &quot;=&quot; &lt;priority&gt;</code></pre></div>
<p>The macro attribute <code>dynamic</code> is equivalent to <code>dynamic(lazy)</code>
and <code>dynamic(&lt;num&gt;)</code> to <code>dynamic(init=&lt;num&gt;)</code>. If a priority
is given it will be dropped by program destructor. The priority has the
same semantic as for the <a href="attr.destructor.html" title="destructor">destructor</a> attribute:  statics with priority 0 are dropped first,
… and finaly statics with priority 65535 are the last dropped.</p>
<p>The <code>drop_only=&lt;priority&gt;</code> is equivalent to #[dynamic(0,drop=<priority>)] except that the
static will be const initialized.</p>
<p>If no priority is given to the drop argument, the drop function will be registered using <code>libc::atexit</code>. All
dynamic statics registered this way will be dropped in the reverse order of their
initialization and before any dynamic statics marked for drop using the <code>drop</code> attribute
argument.</p>

<div class="example-wrap ignore"><div class='tooltip'>ⓘ</div><pre class="rust rust-example-rendered"><code><span class="kw">struct </span>A(i32);

<span class="kw">impl </span>A {
  <span class="comment">//new is not const
  </span><span class="kw">fn </span>new(v:i32) -&gt; A {
    A(v)
  }
  <span class="comment">//new is not const
  </span><span class="kw">const fn </span>const_new(v:i32) -&gt; A {
    A(v)
  }
}

<span class="kw">impl </span>Drop <span class="kw">for </span>A {
    <span class="kw">fn </span>drop(<span class="kw-2">&amp;mut </span><span class="self">self</span>) {}
    }

<span class="comment">//const initialized droped after main exit
</span><span class="attr">#[dynamic(init=<span class="number">0</span>, drop=<span class="number">0</span>)]
</span><span class="kw">static </span><span class="kw-2">mut </span>V1 :A = A::new_const(<span class="number">33</span>);

<span class="comment">//initialized before V1 and droped after V1
</span><span class="attr">#[dynamic(<span class="number">20</span>,drop=<span class="number">10</span>)]
</span><span class="kw">static </span>V2 :A = A::new(<span class="number">10</span>);

<span class="comment">// not droped, V3, V4 and V5 all have initialization priority 0
</span><span class="attr">#[dynamic(init=<span class="number">0</span>)]
</span><span class="kw">static </span>V3 :A = A::new(<span class="number">10</span>);

<span class="comment">// not droped
</span><span class="attr">#[dynamic(init)]
</span><span class="kw">static </span>V4 :A = A::new(<span class="number">10</span>);

<span class="comment">// not droped
</span><span class="attr">#[dynamic(<span class="number">0</span>)]
</span><span class="kw">static </span>V5 :A = A::new(<span class="number">10</span>);

<span class="comment">// not droped
</span><span class="attr">#[dynamic(<span class="number">10</span>)]
</span><span class="kw">static </span>V6 :A = A::new(<span class="number">10</span>);</code></pre></div>
<h2 id="actual-type-of-dynamic-statics"><a href="#actual-type-of-dynamic-statics">Actual type of “dynamic” statics</a></h2>
<p>A thread_local <em>lazy static</em> that is <em>not mutable</em> and that will be dropped is wrapped in a <em>mutable</em> thread_local static
of type <code>static_init::ThreadLocalConstLazy</code>. Otherwise the mutability is unchanged and the
static is wrapped in a <code>static_init::ThreadLocalLazy</code>.</p>
<p>A <em>lazy static</em> that is <em>not mutable</em> and that will be dropped is wrapped in a <em>mutable</em> static
of type <code>static_init::ConstLazy</code>. Otherwise the mutability is unchanged and the
static is wrapped in a <code>static_init::Lazy</code>.</p>
<p>A mutable dynamic static declared to have type <code>T</code> are wrapped in <code>static_init::Static&lt;T&gt;</code>.</p>
<p>A mutable “dynamic” static declared to have type <code>T</code> are wrapped in a mutable static of type <code>static_init::ConstStatic&lt;T&gt;</code> </p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>
<span class="comment">// V has type static_init::ConstStatic&lt;i32&gt;
</span><span class="attr">#[dynamic]
</span><span class="kw">static </span>V :i32 = <span class="number">0</span>;

<span class="comment">// W has type static_init::Static&lt;i32&gt;
</span><span class="attr">#[dynamic]
</span><span class="kw">static </span>W :i32 = <span class="number">0</span>;</code></pre></div>
</div></details></section></div></main><div id="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="static_init" data-themes="" data-resource-suffix="" data-rustdoc-version="1.67.0-nightly (234151769 2022-12-03)" data-search-js="search-444266647c4dba98.js" data-settings-js="settings-bebeae96e00e4617.js" data-settings-css="settings-af96d9e2fc13e081.css" ></div></body></html>